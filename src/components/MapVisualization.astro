---
---

<div class="bg-white rounded-2xl shadow-xl p-6 border border-slate-200">
  <div class="mb-4">
    <h3 class="text-xl font-semibold text-slate-800 mb-2">Carte Tourisme √ó Train</h3>
    <div class="flex gap-4 text-sm">
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-green-500"></div>
        <span class="text-slate-600">Bien desservi</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-orange-400"></div>
        <span class="text-slate-600">Opportunit√©</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-red-500"></div>
        <span class="text-slate-600">Sous-desservi</span>
      </div>
    </div>
  </div>
  <div id="map-container"></div>
</div>

<script>
  import * as d3 from 'd3';
  import * as Plot from '@observablehq/plot';

  // Fonctions utilitaires
  function median(arr: number[]): number {
    const sorted = [...arr].sort((a, b) => a - b);
    const n = sorted.length;
    return n ? (n % 2 ? sorted[(n - 1) / 2] : (sorted[n / 2 - 1] + sorted[n / 2]) / 2) : 0;
  }

  function normalizeTo100(
    mapIn: Map<string, number>,
    allDeps: Set<string>,
    options: { qLow?: number; qHigh?: number; transform?: (x: number) => number } = {}
  ): Map<string, number> {
    const { qLow = 0.05, qHigh = 0.95, transform = (x) => x } = options;

    const tmp = new Map([...allDeps].map((k) => [k, mapIn.get(k)]));
    const valsRaw = [...tmp.values()].filter((v): v is number => Number.isFinite(v));
    const med = median(valsRaw.length ? valsRaw : [0]);
    
    for (const [k, v] of tmp) {
      if (!Number.isFinite(v)) tmp.set(k, med);
    }

    const tv = [...tmp].map(([k, v]) => [k, transform(v!)] as [string, number]);
    const onlyV = tv.map(([, v]) => v).sort((a, b) => a - b);
    const lo = d3.quantileSorted(onlyV, qLow) ?? 0;
    const hi = d3.quantileSorted(onlyV, qHigh) ?? 1;
    const den = hi - lo || 1;

    const out = new Map<string, number>();
    for (const [k, v0] of tv) {
      const v = Math.min(Math.max(v0, lo), hi);
      out.set(k, ((v - lo) / den) * 100);
    }
    return out;
  }

  function deptFromINSEE(insee: string | null): string | null {
    if (!insee) return null;
    const s = String(insee);
    if (s.startsWith('97') || s.startsWith('98')) return s.slice(0, 3);
    if (s.startsWith('2A') || s.startsWith('2B')) return s.slice(0, 2);
    return s.slice(0, 2);
  }

  function deptFromCP(cp: string | null): string | null {
    if (!cp) return null;
    const s = String(cp).padStart(5, '0');
    if (s.startsWith('97') || s.startsWith('98')) return s.slice(0, 3);
    if (s.startsWith('20')) return null;
    return s.slice(0, 2);
  }

  async function loadData() {
    const [deptsGeo, nuiteesDep, popDep, gares, freq, capHotels, capCamp, capAhct] = await Promise.all([
      fetch('/data/departements.geojson').then(r => r.json()),
      fetch('/data/NUITEES_PAR_DEP.json').then(r => r.json()),
      fetch('/data/popraw.json').then(r => r.json()),
      fetch('/data/gares-de-voyageurs.json').then(r => r.json()),
      fetch('/data/frequentation-gares.json').then(r => r.json()),
      fetch('/data/CAPACITES_HOTELS.json').then(r => r.json()),
      fetch('/data/CAPACITES_CAMPINGS.json').then(r => r.json()),
      fetch('/data/CAPACITES_AHCT.json').then(r => r.json())
    ]);

    return { deptsGeo, nuiteesDep, popDep, gares, freq, capHotels, capCamp, capAhct };
  }

  function processData(data: any) {
    const { deptsGeo, nuiteesDep, popDep, gares, freq, capHotels, capCamp, capAhct } = data;

    const nomToCodeDep = new Map(
      deptsGeo.features.map((f: any) => [
        (f.properties.nom || f.properties.NOM).toLowerCase(),
        String(f.properties.code || f.properties.CODE_DEPT)
      ])
    );

    const popByDep = new Map(
      popDep
        .map((d: any) => [nomToCodeDep.get(d["G√©ographie"].toLowerCase()), +d["Valeur"]])
        .filter(([code, val]: any) => code && !isNaN(val))
    );

    const nuiteesByDep = d3.rollup(
      nuiteesDep,
      (v: any) => {
        const total = d3.sum(v, (d: any) => 
          (+d.hotel_nuitees || 0) + (+d.camping_nuitees || 0) + (+d.autres_nuitees || 0)
        );
        const code = String(v[0].code_departement);
        const pop = popByDep.get(code) || 0;
        return pop ? (total / pop) * 1000 : 0;
      },
      (d: any) => String(d.code_departement)
    );

    const allDepCodes = new Set(
      deptsGeo.features.map((f: any) =>
        String(f.properties?.code ?? f.properties?.CODE_DEPT ?? f.properties?.INSEE_DEP ?? f.properties?.code_dep)
      )
    );

    // Calcul km¬≤
    const km2ByDep = new Map(
      deptsGeo.features.map((f: any) => {
        const p = f.properties || {};
        const code = String(p.code || p.CODE_DEPT || p.code_dep || p.INSEE_DEP);
        const areaKm2 = (d3.geoArea(f) * 6371e3 * 6371e3) / 1e6;
        return [code, areaKm2];
      })
    );

    // Gares par d√©partement
    const garesByDep = d3.group(
      gares
        .map((g: any) => {
          const insee = g.codeinsee ?? g.code_insee ?? g.code_insee_commune ?? g.insee ?? g.code_commune_insee;
          return { ...g, dep: deptFromINSEE(insee) };
        })
        .filter((g: any) => g.dep),
      (g: any) => g.dep
    );

    const nbGaresByDep = new Map([...garesByDep].map(([dep, list]) => [dep, list.length]));

    const gare_km2 = new Map(
      [...km2ByDep].map(([code, km2]) => [code, km2 ? (nbGaresByDep.get(code) || 0) / km2 : 0])
    );

    const gares_100k = new Map(
      [...popByDep].map(([code, pop]) => [code, pop ? ((nbGaresByDep.get(code) || 0) / pop) * 100000 : 0])
    );

    const voy2024ByDep = d3.rollup(
      freq,
      (rows: any) => d3.sum(rows, (r: any) => +r.total_voyageurs_2024 || 0),
      (r: any) => deptFromCP(String(r.code_postal))
    );

    const rail_100k = new Map(
      [...popByDep].map(([code, pop]) => [code, pop ? ((voy2024ByDep.get(code) || 0) / pop) * 100000 : 0])
    );

    // Couverture touristique
    const cpsAvecGare = new Set(freq.map((r: any) => String(r.code_postal)));
    
    const capAll = [
      ...(capHotels ?? []).map((d: any) => ({
        cp: String(d.code_postal ?? d.cp ?? d.codePostal),
        places: +(d.places_total ?? d.places ?? d.capacite ?? 0)
      })),
      ...(capCamp ?? []).map((d: any) => ({
        cp: String(d.code_postal ?? d.cp ?? d.codePostal),
        places: +(d.places_total ?? d.places ?? d.capacite ?? 0)
      })),
      ...(capAhct ?? []).map((d: any) => ({
        cp: String(d.code_postal ?? d.cp ?? d.codePostal),
        places: +(d.places_total ?? d.places ?? d.capacite ?? 0)
      }))
    ].filter((d) => d.cp && !Number.isNaN(d.places));

    const coverageByDep = d3.rollup(
      capAll,
      (v: any) => {
        const total = d3.sum(v, (d: any) => d.places);
        const near = d3.sum(v.filter((d: any) => cpsAvecGare.has(d.cp)), (d: any) => d.places);
        return total ? near / total : 0;
      },
      (d: any) => deptFromCP(d.cp)
    );

    // Normalisation des 4 composantes
    const n_gare_km2 = normalizeTo100(gare_km2, allDepCodes);
    const n_gares_100k = normalizeTo100(gares_100k, allDepCodes);
    const n_rail_100k = normalizeTo100(rail_100k, allDepCodes);
    const n_coverage = normalizeTo100(coverageByDep, allDepCodes);

    // IATR brut
    const IATR_raw = new Map(
      [...allDepCodes].map((code) => {
        const score =
          0.25 * (n_gare_km2.get(code) || 0) +
          0.25 * (n_gares_100k.get(code) || 0) +
          0.30 * (n_rail_100k.get(code) || 0) +
          0.20 * (n_coverage.get(code) || 0);
        return [code, score];
      })
    );

    // Recalibrage final
    const vals = [...IATR_raw.values()];
    const min = d3.min(vals) ?? 0;
    const max = d3.max(vals) ?? 1;
    const den = max - min || 1;

    const IATR = new Map([...IATR_raw].map(([k, v]) => [k, ((v - min) / den) * 100]));

    const iatrVals = [...IATR.values()].sort(d3.ascending);
    const q33 = d3.quantileSorted(iatrVals, 0.33) ?? 33;
    const q66 = d3.quantileSorted(iatrVals, 0.66) ?? 66;

    // Points gares
    const pointsGares = gares
      .map((g: any) => {
        const insee = g.codeinsee ?? g.code_insee ?? g.code_insee_commune;
        const dep = deptFromINSEE(insee);
        if (!dep) return null;

        const pos = g.position_geographique ?? g.position;
        let lon = pos?.lon ?? g.longitude ?? (Array.isArray(g.geo_point_2d) ? g.geo_point_2d[1] : null);
        let lat = pos?.lat ?? g.latitude ?? (Array.isArray(g.geo_point_2d) ? g.geo_point_2d[0] : null);

        const iatr = IATR.get(dep) || 0;
        const classe = iatr >= q66 ? 'üü¢ Bien desservi' : iatr >= q33 ? 'üü† Opportunit√©' : 'üî¥ Sous-desservi';

        return {
          dep,
          name: g.nom ?? g.libelle ?? 'Gare',
          lon: +lon,
          lat: +lat,
          iatr,
          classe
        };
      })
      .filter((d: any) => d && Number.isFinite(d.lon) && Number.isFinite(d.lat));

    return { deptsGeo, nuiteesByDep, IATR, pointsGares, q33, q66 };
  }

  async function renderMap() {
    const data = await loadData();
    const { deptsGeo, nuiteesByDep, IATR, pointsGares, q33, q66 } = processData(data);

    const classeIATR = (v: number) =>
      v >= q66 ? 'üü¢ Bien desservi' : v >= q33 ? 'üü† Opportunit√©' : 'üî¥ Sous-desservi';

    const iatrColor = d3.scaleOrdinal()
      .domain(['üî¥ Sous-desservi', 'üü† Opportunit√©', 'üü¢ Bien desservi'])
      .range(['#ef4444', '#fb923c', '#10b981']);

    const plot = Plot.plot({
      width: 600,
      height: 420,
      projection: { type: 'mercator', domain: deptsGeo },
      color: { label: 'Nuit√©es / 1000 hab', scheme: 'blues', legend: true },
      marks: [
        Plot.geo(deptsGeo, {
          fill: (f: any) => {
            const code = String(f.properties.code || f.properties.CODE_DEPT);
            return nuiteesByDep.get(code) || 0;
          },
          stroke: '#334155',
          strokeWidth: 0.5,
          tip: true,
          title: (f: any) => {
            const code = String(f.properties.code || f.properties.CODE_DEPT);
            const n = nuiteesByDep.get(code) || 0;
            const i = IATR.get(code) || 0;
            return `${f.properties.nom}\nNuit√©es/1000: ${n.toFixed(1)}\nIATR: ${i.toFixed(1)} (${classeIATR(i)})`;
          }
        }),
        Plot.dot(pointsGares, {
          x: 'lon',
          y: 'lat',
          r: (d: any) => 2 + d.iatr / 30,
          fill: (d: any) => iatrColor(d.classe),
          stroke: '#1e293b',
          strokeWidth: 0.5,
          opacity: 0.8,
          title: (d: any) => `${d.name}\nIATR: ${d.iatr.toFixed(1)} (${d.classe})`
        })
      ]
    });

    const container = document.getElementById('map-container');
    if (container) {
      container.innerHTML = '';
      container.appendChild(plot);
    }
  }

  renderMap();
</script>